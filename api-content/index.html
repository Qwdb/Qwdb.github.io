{"posts":[{"title":"书评 | 《三体Ⅱ》","content":"书评 《三体Ⅱ》 https://book.douban.com/subject/3066477/ 1.序言 我是面壁者罗辑，我对三体文明说话~ 2.作者简介 来源 刘慈欣，祖籍河南，长于山西，中国科普作家协会会员，山西省作家协会会员，高级工程师。 自1999年处女作《鲸歌》问世以来，刘慈欣已发表短篇科幻小说三十余篇、出版长篇科幻小说六部，并创下连续八年荣获中国科幻最高奖“银河奖”的纪录。他的长篇作品 《三体》 开创《科幻世界》月刊连载原创作品的先例，成为2006年度最受关注、最畅销的科幻小说。 3.本文概括 三体人在利用魔法般的科技锁死了地球人的科学之后，庞大的宇宙舰队杀气腾腾地直扑太阳系，意欲清除地球文明，将地球作为星际殖民地。 面对前所未有的危局，初次进行星际战争的地球人组建起同样庞大的太空舰队，同时，利用三体人思维透明的致命缺陷，制订了“面壁计划”，选出四位“面壁者”，准备从多方面应战。 三体人自身虽然无法识破面壁者神秘莫测，甚至古怪至极的计划，却依靠由ETO挑选出的“破壁人”，与面壁者展开智慧博弈…… 几百年后，两名面壁者先后失败，其他两位进入冬眠。但当他们醒来时，地球已经做好了准备，显得游刃有余，希恩斯带着失望离开，罗辑却十分轻松。 水滴来了，舰队被一个小探测器击败了。 罗辑，将与三体文明直接对决。 “面壁计划”究竟能否成功？ “黑暗森林”究竟意味着什么？ 4.以小见大 章北海，出生于军人家庭，从表面上看去，是一个坚定的共产主义战士。 但从一开始，他内心深处，就看到了人类与三体战争的必败结局。 他的信念从一开始就坚定不移 他为此隐瞒了所有人而孤独地走下去， 他伪装必胜信念，刺杀军中要员使舰队发动机向无工质发展（“陨石雨！”），提出冬眠计划，劫持“自然选择”号太空舰，他说： “我想为人类文明保留一颗种子。” 最终在黑暗战役中随“自然选择”号全员一同牺牲，临死之际，明了真正的超脱。 “没关系的，都一样的。 如果可以，我愿称他为第5位面壁者。 安利一发~ 我的三体之章北海传 夜航星 5.一段话总结 给岁月以文明 而非给文明以岁月 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/santier/"},{"title":"书评 | 《三体》","content":"书评 《三体》 https://book.douban.com/subject/2567698/ 1.序言 消灭人类暴政，世界属于三体~ 2.作者简介 来源 刘慈欣，祖籍河南，长于山西，中国科普作家协会会员，山西省作家协会会员，高级工程师。 自1999年处女作《鲸歌》问世以来，刘慈欣已发表短篇科幻小说三十余篇、出版长篇科幻小说六部，并创下连续八年荣获中国科幻最高奖“银河奖”的纪录。他的长篇作品 《三体》 开创《科幻世界》月刊连载原创作品的先例，成为2006年度最受关注、最畅销的科幻小说。 3.本文概括 文化大革命如火如荼进行的同时，国内军方探寻外星文明的绝秘计划“红岸工程”取得了突破性进展。就在此时，历经劫难的叶文洁按下了发射键，地球文明向宇宙发出的第一声啼鸣。但她没有意识到，她彻底改变了人类的命运。从整个宇宙看来微弱至极，但承载了一个文明的命运的电波，以太阳为中心，以光速向宇宙深处飞驰…… 四光年外，“三体文明”正苦苦挣扎——三颗无规则运行的太阳主导下的百余次毁灭、撕裂、融合逼迫他们准备逃离母星。而恰在此时，他们接收到了地球发来的信息，在运用超技术锁死地球人的基础科学之后。三体人庞大的宇宙舰队开始向地球进发…… 人类的末日来了，悄无声息。 4.以小见大 “三体世界已经让我厌倦了。我们的生活和精神中除了为生存而战就没有其他东西了。” “这有什么错吗？” “当然没有错，生存是其他一切的前提，但，元首，请看看我们的生活：一切都是为了文明的生存。为了整个文明的生存，对个体的尊重几乎不存在，个人不能工作就得死；三体社会处于极端的专制之中，法律只有两档：有罪和无罪，有罪处死，无罪释放。我最无法忍受的是精神生活的单和枯竭，一切可能导致脆弱的精神都是邪恶的。我们没有文学没有艺术，没有对美的追求和享受，甚至连爱情也不能倾诉——元首，这样的生活有意义吗？” “你向往的那种文明在三体世界也存在过，它们有过民主自由的社会，也留下了丰富的文化遗产，你能看到的只是极小一部分，大部分都被封存禁阅了。但在所有三体文明的轮回中，这类文明是最脆弱最短命的，一次不大的乱世纪灾难就足以使其灭绝。再看你想拯救的地球文明，那个在永远如春的美丽温室中娇生惯养的社会，如果放到三体世界，绝对生存不了——百万个三体时。” “那花朵虽然娇弱但是绚丽无比，她在天堂闲适中感受着自由和美。” 引自 三体1379号监听员及三体文明元首 1379号，是多么孤独啊！ 他（暂且用这个称呼吧）整日整夜坐在一间简陋的房屋的门前，屋子里的监视器的画面显示着一条起伏的“线”。 如果没有意外，那将是他整个人生。 他，与叶文洁很像：他们都是发现外星文明的第一人，都是第一次与遥远对话的幸运儿。 但叶文洁冰冷的心中也有过温暖，她成全了自己的执着，她无怨无悔的接受了命运的判决。 而他，做出了负责的选择，同时也发出了没有违背自己意愿的警告。 我想，他找到了自己的使命——守护心中的天堂。他同叶文洁一样，选择了背叛自己的文明。 他们，为了梦想去承担孤独。 5.一段话总结 “你们是虫子！” “虫子从来就没有被战胜过。” 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/santi/"},{"title":"游记 | 5.3 二妃山漫步","content":"1.行程 7：30 出发，吃美味的早餐——面妈妈~ 8：00 到达二妃山 10：00 下山，发现洗车点，洗车去~ 11：00 开始自助洗车 有四个功能：清水，泡沫，吸尘，洗手 优点：更细致，更方便自由，更便宜 缺点：需要自己动手😣 12：00 回家吃饭 2.各位分享 千文杜博： 疫情爆发的第一次出游，实属不易。一路上都要时刻小心，只能偶尔呼吸一口新鲜空气，但依然使我们神清气爽。二妃山，是明朝龙脉所在之地，现处于光谷生物城附近，平常没有人来，适合假日出游，建议带上帐篷，可以静享午时阳光~ PS:附近有自助洗车，可以顺便洗个车~ shmily： 乙亥年，庚子春，一场新肺疫情席卷而来，全民恐慌，武汉成为重灾区，无数生命隔绝于世。情急之间，闭一省拒扩散一国，举一国之力救一省之民，我们的世界突然按下了暂停键，人类从主角退其位还于自然回归家庭。 不知不觉在疫情中度过了二月、三月、四月，封闭在家的日子让人不禁觉得呼吸到一口新鲜的空气都是奢望。春江水暖草长莺飞似乎都在梦中的记忆里，梨花带雨樱花飞扬都飘落在画卷里，桃红柳绿姹紫嫣红也只在友人的朋友圈里。偶有下楼亦是人烟稀少重重设防，只瞥见一夜风雨吹皱了花瓣。 终于开了禁相约透口气，漫步二妃山洗洗心靓靓眼。东西两座山峦叠翠，处处芳菲浸染，好在抓住了春的尾巴。绿道两旁各式野花肆意地开放著，樱桃枇杷硕果累累缀满枝条，疫情给人类放了假，也让自然偷了欢。片片绿草茵茵，释放了眼中的电子色，肆意奔跑绿道间，只有呼吸的畅快。 真希望时间在此停留，停下来慢点，再慢点，生活还需要细细品…… 2.上图 ","link":"https://qwdb.github.io/post/erfeishanmanbu/"},{"title":"题解 | 洛谷 P1496 火烧赤壁 ","content":"P1496 火烧赤壁 题解 难度：⭐⭐⭐ 知识点：模拟 题目链接 序言： 额，这好像是一道离散化题，但我做成了模拟 1. 入手程序 模拟模拟模拟，完事~ 我怎么这么喜欢模拟呢？（小声bb） 2. 编程思路 首先，可以将题目转化一个模型 用样例举例 3 -1 1 5 11 2 9 画图表示： 如果把首尾都sort一遍，会变成： 没有影响！ 所以，我们得到了一个解法：分别对起点和终点数组进行排序，加上每一条线段的长度，若与前一条线段重复减去重复部分，即可算出正确答案~ 3. AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; int n,ans=0; int s[20005],e[20005]; int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s[i]&gt;&gt;e[i]; } sort(s+1,s+1+n); sort(e+1,e+1+n); for(int i=1;i&lt;=n;i++) { ans+=e[i]-s[i];//加上当前长度 if(i+1&lt;=n)//如果不是最后一条,则有可能与前一条重复 { if(e[i]&gt;s[i+1])//如果重复 { ans-=e[i]-s[i+1];//去掉重复 } } } cout&lt;&lt;ans; return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1496/"},{"title":"剧评 |《士兵突击》","content":"剧评 《士兵突击》 https://movie.douban.com/subject/2154096/ 1.序言 许木木~ 2.作者简介 来源 康洪雷，1962年11月6日出生于内蒙古呼和浩特市，国家一级导演。毕业于内蒙古艺术学校话剧表演专业。 1982年，进入内蒙古话剧团当演员。1989年调至内蒙古电视台电视剧制作中心任导演。1996年正式调入内蒙古电视台制作中心任导演。1999年，37岁的康洪雷因第一次独立执导的电视剧《激情燃烧的岁月》而成名。2005年，执导由左小青、刘烨领衔主演的电视剧《一针见血》。2006年，执导军事动作、青春励志剧《士兵突击》。2008年，凭借 电视剧《士兵突击》 获得第24届中国电视金鹰奖最佳导演奖。2011年，执导革命史诗题材电视剧《我们的法兰西岁月》。2012年，担任励志电视剧《推拿》的导演。2014年执导战争电视剧《二炮手》。 3.本剧概括 《士兵突击》记载了一个普通士兵的心路历程，讲述了一个中国军人的传奇故事。由于故事和人物的纯粹，剧中没有一个女性主角，完全是男人的情感世界：意气飞扬的军旅生涯，生死与共的成长岁月；金戈铁马，斗志男儿，士兵的精神世界丰富而冷峻。一个有着性格缺点的普通农村孩子，他单纯而执着，在军人的世界里跌打滚爬。因为他的笨，让全连队受累；因为他的认真，让全连队为之感动；因为他的执着，让全连队战士为之骄傲。既使他家的房屋在爆炸声中变成一堆瓦废墟，却无法阻止他坚毅的军人步伐与坚定的决心；善良的怜悯，并未使他忘记军人的职责，这使他在种种困境和磨难中百炼成钢。 而这个兵的名字叫： 许三多 4.以小见大 成才，是许三多的老乡，与许三多形成鲜明的对比： 特点\\人物 成才 许三多 天赋 优秀，精明 傻，执着，坚持，善良 家境 村长的儿子，家中独子，环境优越 三子，被叫做“龟儿子”，从小被欺凌 处事态度 投机取巧(最初) 舍己为人，不畏艰险 目标 远大，高 脚踏实地，步步成长 三多说： 我是新兵连最早现形的骡子，而成才是新兵连最出色的马。 作为全剧最有争议的一个人物，其实成才也是最现实的形象。现实生活中有一定小聪明，并且胸有大志，但是由于自己过强的目标感，从而忽略了生命中其他人和事的“成才”很多很多。从一开始由于性格而失败到蜕变之后的成功，成才之路或许就是现实中的很多人的成功历程。 5.一段话总结 “有意义就是好好活，好好活就是有意义。” “不要对没有做过的事情说没有意义。” 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/shibingtuji/"},{"title":"书评 |《茶馆》","content":"书评 《茶馆》 https://book.douban.com/subject/1036613/ 1.序言 书评系列第一篇，希望越来越好~ 2.作者简介 来源 老舍（1899年2月3日—1966年8月24日），男，原名舒庆春，字舍予，另有笔名絜青、鸿来、非我等。因为老舍生于阴历立春，父母为他取名“庆春”，大概含有庆贺春来、前景美好之意。上学后，自己更名为舒舍予，含有“舍弃自我”，亦即“忘我”的意思。北京满族正红旗人。中国现代小说家、作家，语言大师、人民艺术家，新中国第一位获得“人民艺术家”称号的作家。代表作有《骆驼祥子》《四世同堂》，剧本《茶馆》。 老舍的一生，总是忘我地工作，他是文艺界当之无愧的“劳动模范”。1966年8月24日，由于受到文化大革命运动中恶毒的攻击和迫害，老舍被逼无奈之下含冤自沉于北京太平湖。2017年9月，中国现代文学长篇小说经典《四世同堂》由东方出版中心出版上市。这是该作自发表以来第一次以完整版形式出版。 3.本文概括 本文主要讲述了民国时期裕泰大茶馆从1898年到1945年倒闭间的变故，虽只讲小小一家茶馆里的事，却讲出了无数人的悲惨遭遇。充分的展现了一个充满白色恐怖的怪异丑陋，伦理扭曲的时代，揭示了旧社会必然灭亡的事实。 4.以小见大 《茶馆》中贯穿全文的便是茶馆掌柜王利发的形象了。王利发是一个勤勤恳恳的人，他处事圆滑，处处小心，凡是见到人，都恭恭敬敬的鞠躬： 人缘顶要紧，多说好话，多请安，讨人人的喜欢，就不会出大岔子。 甚至连相面为生的唐铁嘴都自叹弗如： 你的嘴比我的还花哨 他每天满脸堆笑，希望社会安定，只想活下去。 但 又怎么样了呢？ 国民党威胁要砸他的馆子，特务向他勒索他根本拿不出的金条，流氓要强占他的店面 直到死，他才说出： 人总得活吧？我变尽了办法，不过是为了活下去！ 一个如此卑微，只想活下去的人，就是旧社会人民生活的真实写照。 5.一段话总结 描绘了一段历史，写活了一个时代 于市井之地，看人生百态，尝人情冷暖 于方寸之地，品悲欢离合，感世事沧桑 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/chaguan/"},{"title":"题解 | 洛谷 P1794 装备运输","content":"P1794 装备运输 题解 难度：⭐⭐ 知识点：背包 题目链接 序言：做水一道背包练练手~ 1. 入手程序 01背包，三重限制，直接开整~ 2. 编程思路 唉，说实话，这个题没什么难点，但这儿总不能空着吧? 给个01背包模板吧 for(int i=1;i&lt;=n;i++) { for(int j=v;j&gt;=v[i];j--) { for(int k=u;k&gt;=u[i];k--) { //重复限制个数-1次 //动态转移方程 } } } 3. AC代码 //V和G表示最大体积和重量 //N表示仓库有N件装备 //每行3个数hi ti zi表示各装备的火力值、体积和重量 #include&lt;bits/stdc++.h&gt; using namespace std; int v,g,n; int h[505],t[505],z[505]; int dp[505][505]; int main() { cin&gt;&gt;v&gt;&gt;g&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;h[i]&gt;&gt;t[i]&gt;&gt;z[i]; } for(int i=1;i&lt;=n;i++) { for(int j=v;j&gt;=t[i];j--) { for(int k=g;k&gt;=z[i];k--) { dp[j][k]=max(dp[j-t[i]][k-z[i]]+h[i],dp[j][k]);//动态转移方程 } } } cout&lt;&lt;dp[v][g]; return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1794/"},{"title":"题解 | 啊哈添柴 12722. 差分入门","content":"12722. 差分入门 题解 难度：⭐⭐⭐⭐ 知识点：差分 题目链接 序言： 第一次写在添柴上的题的题解，嗯嗯呃呃.... 1. 入手程序 这道题可以约等于一个裸题，就是一个基本的区间修改题目，连查询都不需要！ 但这道题的数据不小，不能直接一个数组直接进行该动，可以作为差分的入门题~ 2. 编程思路 神马是差分呢？差分指的是每一次改动不直接影响结果，而是把改动存储在一个临时空间中。 比如这一题，不把每次的改动直接放在答案数组a里，而是放在差分数组k里 （然后这样再那样在布拉布拉。。。。） 好吧，我承认老师讲的这一段真的很难懂 那我来用样例说明一下 开始时a数组为：1 5 7 3 6 9 实际变化过程为： 1 5 7 3 6 9 1 5 7 6 9 12 1 6 8 7 10 12 1 6 10 9 12 14 k[i]初始化为a[1],k [i]初始化为a[i]-a[i-1] f[i]=a[i]-a[i-1]; 结果为：1，4，2，-4，3，3 第一个步骤：第四到第六位加3 k对应操作：第四位+3，第七位-3（当然，本样例没有第七位） 第二个步骤：第二到第五位加1 k对应操作：第二位+1，第六位-3 第三个步骤：第三到第六位加2 k对应操作：第三位+2，第七位-2（同上） 代码就是： f[A]+=C; if(B!=n) { f[B+1]-=C; } 最后不要忘了k数组要逐位加到a数组上哦~ 3. AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; int A,B,C; int a[100005],f[100005]; int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } for(int i=1;i&lt;=n;i++) { f[i]=a[i]-a[i-1]; } cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;A&gt;&gt;B&gt;&gt;C; if(A&gt;B) { swap(A,B); } f[A]+=C; if(B!=n) { f[B+1]-=C; } } for(int i=1;i&lt;=n;i++) { a[i]=a[i-1]+f[i]; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/12722/"},{"title":"笔记 | 图论","content":"①最短路 Floyd 算法 for(int k=1; k&lt;=n; k++) { for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { if(MAP[i][k]+MAP[k][j]&lt;MAP[i][j]) { MAP[i][j]=MAP[i][k]+MAP[k][j]; } } } } ②图 连通性 ：两点之间是否有关系 有向性 ：关系有方向 未完待续~（如果有dalao有补充欢迎评论补充） 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/tl/"},{"title":"笔记 | 堆与树","content":"①树 有n个节点的树有(n-1)条边 树：无环无向图，任意两点之间只有一条边 经过所有边回到原点--哈密尔顿回路 经过所有点回到原点--欧拉回路 中序：父亲在中间，左儿子在左边，左儿子在右边(人脑习惯) vectora :定义不定长数组 a.push_back :加入元素 a.size() :获取元素个数 二叉树：每个节点最多有两个子树的树。 完全二叉树：一棵深度为h的二叉树，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就 是完全二叉树。 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子 结点的二叉树。 生成哈夫曼树 将权值从大到小排序 取2个数做子节点，建一个空白父节点 将新建的树放回序列 重复步骤2 FBI树 B:只有0的 I:只有1的 F:其他的j ②图 堆就是完全二叉树。 最大堆：根结点的键值是所有堆结点键值中最大者的堆。 最小堆：根结点的键值是所有堆结点键值中最小者的堆。 最小堆排序 #include&lt;bits/stdc++.h&gt; using namespace std; int n; int heap[11]={0,1,8,2,11,12,4,6}; int ans[8]; void d(int i) { int t; while(i*2&lt;=n) { t=i; if(heap[2*i]&lt;heap[i]) { t=2*i; } else { t=i; } if(2*i+1&lt;=n) { if(heap[2*i+1]&lt;heap[t]) { t=2*i+1; } } if(t!=i) { swap(heap[t],heap[i]); i=t; } else break; } return; } int main() { heap[1]=10; n=7; d(1); int k = 0; while(n&gt;0) { k++; ans[k] = heap[1]; heap[1] = heap[n]; n--; d(1); } for(int i=1;i&lt;=7;i++) { cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; } return 0; } 正确结果：2 4 6 8 10 11 12 ③其他 queue-&gt;队列 位运算 x&gt;&gt;1 除以2 x&lt;&lt;1 乘以2 可以用来计算x的n次方 pow函数 power ：求冥 pow(x,y) :求x的y次方 floor(x)向下取整，返回一个&lt;=x的int整型。 ceil(x)向上取整，返回一个&gt;=x的int整型。 用一个数据和数据的关系，通过图和线段之间的关系来表示。 前提条件：BFS 未完待续~（如果有dalao有补充欢迎评论补充） 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/dys/"},{"title":"题解 | 洛谷 P1057 传球游戏","content":"P1057 传球游戏 题解 难度：⭐⭐⭐ 知识点：传球法 题目链接 序言： 我看题解中除了各种对于我这个蒟蒻来说稀奇古怪高深莫测的方法之外就只有用二维数组的了，所以我决定来发一篇用初学者们也都熟悉的一维数组也能AC的方法。 1.入手程序 一拿到题，哇！完全没思路哇( ⊙o⊙ ) 所以，画个表吧！ 由于我们知道小蛮一定在第一位，所以我们可以用一个数组来模拟这个圈： 可能传到次数\\人 1（小蛮） 2 3 开始时 1 0 0 第一次传球 0 1 1 第二次传球 2 1 1 第三次传球 2 3 3 好了，定义好了数组，就可以开始准备模拟了。我们先画一个表：（样例一） 现在我们看到，第三次传球后小蛮有两种可能性手上有球，分别是1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，因此我们知道了每次把有球的人的旁边两个人加上这个人的可能次数，就可以得到正确结果。（这其实就是小学奥数传球法） 2.编程思路 上面的一句话有一些难懂，这里用代码解释一下： a[j+1]+=a[j]; a[j-1]+=a[j]; 所以，我们的任务就是模拟这个过程。 注意： 1.不应该用数值来判断是否到边界（0或n），而应该用下标来判断 2.a[j]不能直接为零，而是减去上一次传球的可能次数（因为可能不仅他要传给别人，别人也要传给他） 对应解决方案： 1.改为j-1和j+1 2.使用一个b数组来存储上一次的 3.AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int mm=40; int n,m; int a[mm],b[mm]; int main() { //读入 cin&gt;&gt;n&gt;&gt;m; a[1]=b[1]=1; //循环m次传球 for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { //分不同情况处理，这里开两个数组，类似于差分操作 if(a[j]&gt;=1) { if(j-1&lt;1) { a[n]+=b[j]; } else { a[j-1]+=b[j]; } if(j+1&gt;n) { a[1]+=b[j]; } else { a[j+1]+=b[j]; } a[j]-=b[j]; } } //加起来 for(int j=1;j&lt;=n;j++) { b[j]=a[j]; } } //输出1号也就是小强的可能传到数量 cout&lt;&lt;a[1]; return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1057/"},{"title":"题解 | 洛谷 P2799 国王的魔镜","content":"P2799 国王的魔镜 题解 难度：⭐⭐⭐ 知识点：模拟 题目链接 序言： 我看题解中各种方法我这个蒟蒻都理解不了，所以我决定来发一篇模拟也能AC的代码。 1.入手程序 根据题意，我们的模拟过程就是倒退项链的变化过程。那么项链在什么情况下可以增长呢？不妨先看看样例： ABBAABBA 2 样例中的项链的变化过程如下： AB-&gt;ABBA-&gt;ABBAABBA 因此，可以推导出两条规则： （1）项链只要变化过，它的长度就一定是偶数。 （2）项链只要变化过，它就一定是一个回文字符串（类似于回文数）。 2.编程思路 上面推导出了两项规则，但是还不足以帮助我们来模拟项链变化过程，因为它是正向的，于是继续推导,终于推出了代码的核心! 如果项链的长度是偶数且回文，它就有可能是变化过的。 并且由于我们要求最初的项链可能的最小长度，所以就意味着...... 如果项链的长度是偶数且回文，它项链的长度就能缩短！ 所以，我们的任务就是模拟这个过程。 3.AC代码 终于到了激动人心的AC时刻！ #include&lt;bits/stdc++.h&gt; using namespace std; string s; //递归倒推 int mj(string s) { int sl=s.size(); //如果是奇数就一定是最开始的结果 if(sl%2==1) { return sl; } string s2=s; reverse(s2.begin(),s2.end());//rerse函数是判断一个字符串是否回文的一个工具，具体用法为：reverse(字符串.begin(),字符串.end()) //如果是偶数就据续处理 if(s==s2) { string ts; for(int i=1;i&lt;=sl/2;i++) { ts+=s[i-1]; } return mj(ts); } return sl; } int main()//好短的主函数啊~ { cin&gt;&gt;s; cout&lt;&lt;mj(s);//直接输出处理后的结果 return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P2799/"},{"title":"题解 | 洛谷 P1417 烹调方案","content":"P1417 烹调方案 题解 难度：⭐⭐⭐⭐ 知识点：DP 题目链接 序言： 最近在练DP，刷到了这道题，众所周知，DP最重要的是有大佬给出能推出状态转移方程，这题就是这样的一题~ 1.入手程序 一看：嗯~是一道明显的DP 再看：咦~好像不对劲，这是什么？ 如果在t时刻完成第i样食材则得到ai-t*bi的美味指数 一想：啊~ 原来不是基本DP啊，看起来好难溜了溜了 再想：嘿~ 怎么能这样轻易放弃呢！ 开始推状态转移方程！ 2.编程思路 首先，这个题状态转移方程难推的地方在于，因为有b[i]的存在，一件食材先后制作获得的美味指数不同，那么~ sort大法好！ cmp怎么写呢？ 慢慢推吧~ （强烈建议此时在看题解的你停下来推一下） 推完了么？ 往下看吧???? 关于每两个食材i和j，先做i和先做j的美味指数分别为： 1.a[i]-(t+c[i])*b[i]+a[j]-(t+c[i]+c[j])*b[j] 2.a[j]-(t+c[j])*b[j]+a[i]-(t+c[i]+c[j])*b[i] 如果1&gt;2： a[i]-t*b[i]-c[i]*b[i]+a[j]-t*b[j]-c[i]*b[j]-c[j]*b[j]&gt; a[j]-t*b[j]-c[j]*b[j]+a[i]-t*b[i]-c[i]*b[i]-c[j]*b[i] ↓ -t*b[i]-c[i]*b[i]-t*b[j]-c[i]*b[j]-c[j]*b[j]&gt; -t*b[j]-c[j]*b[j]-t*b[i]-c[i]*b[i]-c[j]*b[i] ↓ -c[i]*b[j]&gt;-c[j]*b[i] ok~ 羌湖~ 起飞~ 嗯嗯，还有一句话想说 十年OI一场空，不开long long见祖宗 3.AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; struct Node { long long a,b,c; }s[55]; long long t,n; long long dp[100005]; long long ans; bool cmp(Node x,Node y) { return -x.c*y.b&gt;-y.c*x.b;//这短短的一行，我推了多久啊。。。 } int main() { //读入 cin&gt;&gt;t&gt;&gt;n; for(long long i=1;i&lt;=n;i++)//其实这些地方可以不开long long { cin&gt;&gt;s[i].a; } for(long long i=1;i&lt;=n;i++) { cin&gt;&gt;s[i].b; } for(long long i=1;i&lt;=n;i++) { cin&gt;&gt;s[i].c; } //排序 sort(s+1,s+1+n,cmp);//sort大法好！ //01背包dp for(long long i=1;i&lt;=n;i++) { for(long long j=t;j&gt;=s[i].c;j--) { dp[j]=max(dp[j],dp[j-s[i].c]+s[i].a-s[i].b*j); ans=max(ans,dp[j]); } } //输出 cout&lt;&lt;ans; return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1417/"},{"title":"题解 | 洛谷 P1125 笨小猴","content":"P1125 笨小猴 题解 难度：⭐⭐⭐ 知识点：暴力 题目链接 序言： 以前没过审的一篇博客，再写一遍吧，留作纪念 1. 入手程序 这句话是我们入手的关键↓ 一个单词，其中只可能出现小写字母，并且长度小于100 这说明数据很小，小到可以.. 暴力模拟 2. 编程思路 读入 通过ASCLL码记录每个字母出现个数。 寻找出现次数最多的字母的出现个数 寻找出现次数最少的字母的出现个数 判断加输出 注意 质数的特判 本题中maxn-minn可能等于0或1！（感谢样例二） if(x==0 || x==1) { return 0; } 寻找出现次数最少的字母时的特判 不是所有字母都一定要出现在一个单词里！所以次数可能是0！ if(z[i]&lt;small &amp;&amp; z[i]!=0) { small=z[i]; } 3. AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; string s;//读入的单词 int z[30];//记录每个字母出现了多少次。 int sf(int x)//判断质数，不多解释 { if(x==0 || x==1) { return 0; } for(int i=2;i&lt;=sqrt(x);i++) { if(x%i==0) { return 0; } } return 1; } int main() { cin&gt;&gt;s; //读入 int l=s.size(); for(int i=0;i&lt;l;i++) //通过ASCLL码记录每个字母出现个数。 { z[int(char(s[i]))-96]++; } int big=0; for(int i=1;i&lt;=26;i++)//寻找出现次数最多的字 母的出现个数 { if(z[i]&gt;big) { big=z[i]; } } int small=101; for(int i=1;i&lt;=26;i++)//寻找出现次数最少的字母的出现个数 { if(z[i]&lt;small &amp;&amp; z[i]!=0) { small=z[i]; } } if(sf(big-small)==1)//判断输出 { cout&lt;&lt;&quot;Lucky Word&quot;&lt;&lt;endl&lt;&lt;big-small; } else{ cout&lt;&lt;&quot;No Answer&quot;&lt;&lt;endl&lt;&lt;&quot;0&quot;; } return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1125/"},{"title":"题解 | 洛谷 P1112 波浪数","content":"P1112 波浪数 题解 难度：⭐⭐ 知识点：构造法 题目链接 序言：以后想不出序言说什么就放一句名言吧 我们都是阴沟里的虫子,但总还是得有人仰望星空 ——刘慈欣 《三体》 1. 入手程序 第一步，分析数据，暴力肯定不行 第二部，考虑是否可以模拟，发现虽然不能纯模拟，但可以使用... 构造法 2. 编程思路 所谓的构造法，指的是逆向的通过枚举或其他方法来构造出题目要求的数或情况 具体到这一题，就是枚举i进制下j，k轮流出现构成的波浪数的存在并存到对应重数数组下 最后将题目要求的重数输出出来 注意： 一位数也可以是波浪数 波浪数轮流出现的两个数不能一样 波浪数不一定要是“ababab...”形式，也可以是“abababa...”形式 一个波浪数不一定一定要在十进制下是波浪数 3. AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; int m[10000005];//存重数 int a,b,c,d,e; int main() { cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e; for(int i=a;i&lt;=b;i++)//在i进制下 { for(int j=0;j&lt;i;j++)//枚举第一个数 { for(int k=1;k&lt;i;k++)//枚举第二个数 { if(j!=k)//两数不能一样 { int v1=0;//构造用 int v2=0;//计数 用 while(v1&lt;=d) { //循环用两个数构造 if(v2%2==0) { v1=v1*i+j; } else { v1=v1*i+k; } v2++; if(v1&gt;=c &amp;&amp; v1&lt;=d) { m[v1]++;//如果是波浪数，存到对应位置 } } } } } } for(int i=c;i&lt;=d;i++) { if(m[i]==e)//如果有题目要求的重数，输出 { cout&lt;&lt;i&lt;&lt;endl; } } return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1112/"},{"title":"题解 | 洛谷 P3369 【模板】普通平衡树","content":"P3369 【模板】普通平衡树 题解 难度：⭐⭐⭐⭐⭐ 知识点：平衡树 题目链接 序言：调了超久的一道题！向提高组冲击的第一步！treap！ 1. 入手程序 模板题么，就没什么思路了，既然是练习treap，直接开整呗~ 2. 编程思路 首先，Treap=Tree+Heap，Tree指的是二叉排序树，Heap则是指堆 它融合了二叉排序树的优点：操作方便、多样 同时使用堆结构，和随机值规避了二叉排序树容易退化成一条链的问题 剩下的看代码吧~ 放心，注释多到爆炸 3. AC代码 /* size[i] 以i为根的子树的节点数 v[i] i节点的权值 num[i] 由于可能有重复（上文讲的是没有重复的），所以，我们将权值一样的存在一个节点里面，num数组存储的是i节点存的个数 son[i][2] 存储i节点的儿子，注意，这里不是完全二叉树所以需要存储儿子，son[i][0]表示左儿子，son[i][1]表示右儿子。 rd[i] i节点的一个随机值 */ #include&lt;bits/stdc++.h&gt; using namespace std; const int MAX=100500; int n; int size[MAX],num[MAX],v[MAX],son[MAX][2],rd[MAX]; int x,opt,r,sum;//x,opt与题干中同义，sum为节点个数 void gx(int g)//更新节点个数 { size[g]=size[son[g][0]]+size[son[g][1]]+num[g]; //g的节点数=左右儿子节点数之和+g本身存有数量 } void xz(int &amp;g,int d)//旋转，以g为根，d=0左旋，反之右旋 { //x^1时,如果x为偶数则为x+1，否则为x-1 //这里相当于1变0，0变1 int v1=son[g][d^1];//左旋时，v1为g的右儿子，反之为g的左儿子 son[g][d^1]=son[v1][d]; //左旋时，g的右儿子变成v1的左儿子,反之g的左儿子变成v1的右儿子 son[v1][d]=g; //左旋时，v1的左儿子变成g,反之v1的右儿子变成g gx(g); gx(v1); //更新父节点子节点个数 g=v1;//最后换根 } void cr(int &amp;g,int x)//插入，以g为根，插入x { if(!g)//空树 { g=++sum;//节点总数加1 size[g]=num[g]=1;//于是有1个节点在树中了,当前节点有1个重复数字 v[g]=x;//值为x rd[g]=rand();//生成随机值，拿来维护堆，防止退化成链 return; } if(v[g]==x)//已有该权值，那么直接个数加加即可 { num[g]++; size[g]++; return; } //继续向下寻找 int v1=(x&gt;v[g]);//左儿子或右二子 cr(son[g][v1],x); if(rd[g]&lt;rd[son[g][v1]])//这样转不破坏堆的性质 { xz(g,v1^1);//旋转 //x^1时,如果x为偶数则为x+1，否则为x-1 //这里相当于1变0，0变1 } gx(g);//更新父节点子节点个数 } void sc(int &amp;g,int x)//根为g，删除x { if(!g)//空节点，不可能有要删的这个点 { return; } //如果x和v[g]不相等，直接转到相应子树解决问题 if(x&lt;v[g]) { sc(son[g][0],x); } else if(x&gt;v[g]) { sc(son[g][1],x); } else//就在这棵树 { if(!son[g][0] &amp;&amp; !son[g][1]) //木有在节点啦，x是叶子节点 { num[g]--; size[g]--; //扣掉个数 if(num[g]==0)//如果没数了，删除节点 { g=0; } } else if(son[g][0] &amp;&amp; !son[g][1]) { xz(g,1);//转~ sc(son[g][1],x); } else if(!son[g][0] &amp;&amp; son[g][1]) { xz(g,0);//转~ sc(son[g][0],x); } else if(son[g][0] &amp;&amp; son[g][1])//俩都有，转大的 { int v1=(rd[son[g][0]]&gt;rd[son[g][1]]);//按随机值排，完美避开强迫症~ xz(g,v1);//转~ sc(son[g][v1],x); } } gx(g); } int pm(int &amp;g,int x)//根为g,查询x的排名 { if(!g)//空空如也~ { return 0; } if(v[g]==x)//返回左子树个数+1 { return size[son[g][0]]+1; } if(v[g]&lt;x)//x在右子树，返回左子树个数+在右子树的排名 { return size[son[g][0]]+num[g]+pm(son[g][1],x); } if(v[g]&gt;x)//x在左子树，返回在左子树的排名 { return pm(son[g][0],x); } } int cx(int &amp;g,int x) { if(g==0)//又是空空如也~ { return 0; } if(size[son[g][0]]&gt;=x)//左子树节点数&gt;x，在左节点里找 { return cx(son[g][0],x); } else if(size[son[g][0]]+num[g]&lt;x)//左节点节点数&lt;x，查右子树的第x-左子树节点个数-根储存个数 { return cx(son[g][1],x-num[g]-size[son[g][0]]); } else//当前就是要找的 { return v[g]; } } int qq(int g,int x)//根为g，求x的前驱 { if(g==0)//还是空空如也~ { return -2000000005; } else if(v[g]&gt;=x)//在根或右子树，去左子树找 { return qq(son[g][0],x); } else//在左子树，取根和右子树最大的那一个 { return max(v[g],qq(son[g][1],x)); } } int hj(int g,int x)//根为g，求x的后继 { if(g==0)//依旧空空如也~ { return 2000000005; } if(v[g]&lt;=x)//在根或左子树，去右子树找 { return hj(son[g][1],x); } else//在左子树，取根或右子树最小的那一个 { return min(v[g],hj(son[g][0],x)); } } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;opt&gt;&gt;x; if(opt==1)//插入 x 数 { cr(r,x); } else if(opt==2)//删除 x 数(若有多个相同的数，因只删除一个) { sc(r,x); } else if(opt==3)//查询 x 数的排名(排名定义为比当前数小的数的个数 +1 ) { cout&lt;&lt;pm(r,x)&lt;&lt;endl; } else if(opt==4)//查询排名为 x 的数 { cout&lt;&lt;cx(r,x)&lt;&lt;endl; } else if(opt==5)//求 x 的前驱(前驱定义为小于 x，且最大的数) { cout&lt;&lt;qq(r,x)&lt;&lt;endl; } else if(opt==6)//求 x 的后继(后继定义为大于 x，且最小的数) { cout&lt;&lt;hj(r,x)&lt;&lt;endl; } } return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P3369/"},{"title":"求求你们啦，看看这儿吧！！！","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 评论请留下名字，或者你的主页网址，如果需要头像可以找我申请~ 在这篇文章下留言~ 🏠 关于本站 这是一个小蒟蒻的博客~ 👨‍💻 博主是谁 千文杜博~ ⛹ 兴趣爱好 码code，写homework，看books，观movies 📬 联系我呀 洛谷 bilibili 网易云音乐 微信 QQ ","link":"https://qwdb.github.io/post/about/"}]}