{"posts":[{"title":"书评 《茶馆》","content":"#书评 《茶馆》 https://book.douban.com/subject/1036613/ 1.作者简介 来源 老舍（1899年2月3日—1966年8月24日），男，原名舒庆春，字舍予，另有笔名絜青、鸿来、非我等。因为老舍生于阴历立春，父母为他取名“庆春”，大概含有庆贺春来、前景美好之意。上学后，自己更名为舒舍予，含有“舍弃自我”，亦即“忘我”的意思。北京满族正红旗人。中国现代小说家、作家，语言大师、人民艺术家，新中国第一位获得“人民艺术家”称号的作家。代表作有《骆驼祥子》《四世同堂》，剧本《茶馆》。 老舍的一生，总是忘我地工作，他是文艺界当之无愧的“劳动模范”。1966年8月24日，由于受到文化大革命运动中恶毒的攻击和迫害，老舍被逼无奈之下含冤自沉于北京太平湖。2017年9月，中国现代文学长篇小说经典《四世同堂》由东方出版中心出版上市。这是该作自发表以来第一次以完整版形式出版。 2.本文概括 本文主要讲述了民国时期裕泰大茶馆从1898年到1945年倒闭间的变故，虽只讲小小一家茶馆里的事，却讲出了无数人的悲惨遭遇。充分的展现了一个充满白色恐怖的怪异丑陋，伦理扭曲的时代，揭示了旧社会必然灭亡的事实。 ###3.以小见大 《茶馆》中贯穿全文的便是茶馆掌柜王利发的形象了。王利发是一个勤勤恳恳的人，他处事圆滑，处处小心，凡是见到人，都恭恭敬敬的鞠躬： 人缘顶要紧，多说好话，多请安，讨人人的喜欢，就不会出大岔子。 甚至连相面为生的唐铁嘴都自叹弗如： 你的嘴比我的还花哨 他每天满脸堆笑，希望社会安定，只想活下去。 但 又怎么样了呢？ 国民党威胁要砸他的馆子，特务向他勒索他根本拿不出的金条，流氓要强占他的店面 直到死，他才说出： 人总得活吧？我变尽了办法，不过是为了活下去！ 一个如此卑微，只想活下去的人，就是旧社会人民生活的真实写照。 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/chaguan/"},{"title":"洛谷 P1794 装备运输","content":"P1794 装备运输 题解 题目链接 序言：做水一道背包练练手~ 1. 入手程序 01背包，三重限制，直接开整~ 2. 编程思路 唉，说实话，这个题没什么难点，但这儿总不能空着吧? 给个01背包模板吧 for(int i=1;i&lt;=n;i++) { for(int j=v;j&gt;=v[i];j--) { for(int k=u;k&gt;=u[i];k--) { //重复限制个数-1次 //动态转移方程 } } } 3. AC代码 //V和G表示最大体积和重量 //N表示仓库有N件装备 //每行3个数hi ti zi表示各装备的火力值、体积和重量 #include&lt;bits/stdc++.h&gt; using namespace std; int v,g,n; int h[505],t[505],z[505]; int dp[505][505]; int main() { cin&gt;&gt;v&gt;&gt;g&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;h[i]&gt;&gt;t[i]&gt;&gt;z[i]; } for(int i=1;i&lt;=n;i++) { for(int j=v;j&gt;=t[i];j--) { for(int k=g;k&gt;=z[i];k--) { dp[j][k]=max(dp[j-t[i]][k-z[i]]+h[i],dp[j][k]);//动态转移方程 } } } cout&lt;&lt;dp[v][g]; return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1794/"},{"title":"啊哈添柴 12722. 差分入门","content":"12722. 差分入门 题解 题目链接 序言： 第一次写在添柴上的题的题解，嗯嗯呃呃.... 1. 入手程序 这道题可以约等于一个裸题，就是一个基本的区间修改题目，连查询都不需要！ 但这道题的数据不小，不能直接一个数组直接进行该动，可以作为差分的入门题~ 2. 编程思路 神马是差分呢？差分指的是每一次改动不直接影响结果，而是把改动存储在一个临时空间中。 比如这一题，不把每次的改动直接放在答案数组a里，而是放在差分数组k里 （然后这样再那样在布拉布拉。。。。） 好吧，我承认老师讲的这一段真的很难懂 那我来用样例说明一下 开始时a数组为：1 5 7 3 6 9 实际变化过程为： 1 5 7 3 6 9 1 5 7 6 9 12 1 6 8 7 10 12 1 6 10 9 12 14 k[i]初始化为a[1],k [i]初始化为a[i]-a[i-1] f[i]=a[i]-a[i-1]; 结果为：1，4，2，-4，3，3 第一个步骤：第四到第六位加3 k对应操作：第四位+3，第七位-3（当然，本样例没有第七位） 第二个步骤：第二到第五位加1 k对应操作：第二位+1，第六位-3 第三个步骤：第三到第六位加2 k对应操作：第三位+2，第七位-2（同上） 代码就是： f[A]+=C; if(B!=n) { f[B+1]-=C; } 最后不要忘了k数组要逐位加到a数组上哦~ AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; int A,B,C; int a[100005],f[100005]; int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; } for(int i=1;i&lt;=n;i++) { f[i]=a[i]-a[i-1]; } cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;A&gt;&gt;B&gt;&gt;C; if(A&gt;B) { swap(A,B); } f[A]+=C; if(B!=n) { f[B+1]-=C; } } for(int i=1;i&lt;=n;i++) { a[i]=a[i-1]+f[i]; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/12722/"},{"title":"笔记 图论","content":"①最短路 Floyd 算法 for(int k=1; k&lt;=n; k++) { for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { if(MAP[i][k]+MAP[k][j]&lt;MAP[i][j]) { MAP[i][j]=MAP[i][k]+MAP[k][j]; } } } } ②图 连通性 ：两点之间是否有关系 有向性 ：关系有方向 未完待续~（如果有dalao有补充欢迎评论补充） 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/tl/"},{"title":"笔记 堆与树","content":"①树 有n个节点的树有(n-1)条边 树：无环无向图，任意两点之间只有一条边 经过所有边回到原点--哈密尔顿回路 经过所有点回到原点--欧拉回路 中序：父亲在中间，左儿子在左边，左儿子在右边(人脑习惯) vectora :定义不定长数组 a.push_back :加入元素 a.size() :获取元素个数 二叉树：每个节点最多有两个子树的树。 完全二叉树：一棵深度为h的二叉树，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就 是完全二叉树。 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子 结点的二叉树。 生成哈夫曼树 将权值从大到小排序 取2个数做子节点，建一个空白父节点 将新建的树放回序列 重复步骤2 FBI树 B:只有0的 I:只有1的 F:其他的j ②图 堆就是完全二叉树。 最大堆：根结点的键值是所有堆结点键值中最大者的堆。 最小堆：根结点的键值是所有堆结点键值中最小者的堆。 最小堆排序 #include&lt;bits/stdc++.h&gt; using namespace std; int n; int heap[11]={0,1,8,2,11,12,4,6}; int ans[8]; void d(int i) { int t; while(i*2&lt;=n) { t=i; if(heap[2*i]&lt;heap[i]) { t=2*i; } else { t=i; } if(2*i+1&lt;=n) { if(heap[2*i+1]&lt;heap[t]) { t=2*i+1; } } if(t!=i) { swap(heap[t],heap[i]); i=t; } else break; } return; } int main() { heap[1]=10; n=7; d(1); int k = 0; while(n&gt;0) { k++; ans[k] = heap[1]; heap[1] = heap[n]; n--; d(1); } for(int i=1;i&lt;=7;i++) { cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;; } return 0; } 正确结果：2 4 6 8 10 11 12 ③其他 queue-&gt;队列 位运算 x&gt;&gt;1 除以2 x&lt;&lt;1 乘以2 可以用来计算x的n次方 pow函数 power ：求冥 pow(x,y) :求x的y次方 floor(x)向下取整，返回一个&lt;=x的int整型。 ceil(x)向上取整，返回一个&gt;=x的int整型。 用一个数据和数据的关系，通过图和线段之间的关系来表示。 前提条件：BFS 未完待续~（如果有dalao有补充欢迎评论补充） 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/dys/"},{"title":"洛谷 P1057 传球游戏","content":"P1057 传球游戏 题解 题目链接 序言： 我看题解中除了各种对于我这个蒟蒻来说稀奇古怪高深莫测的方法之外就只有用二维数组的了，所以我决定来发一篇用初学者们也都熟悉的一维数组也能AC的方法。 1.入手程序 一拿到题，哇！完全没思路哇( ⊙o⊙ ) 所以，画个表吧！ 由于我们知道小蛮一定在第一位，所以我们可以用一个数组来模拟这个圈： 可能传到次数\\人 1（小蛮） 2 3 开始时 1 0 0 第一次传球 0 1 1 第二次传球 2 1 1 第三次传球 2 3 3 好了，定义好了数组，就可以开始准备模拟了。我们先画一个表：（样例一） 现在我们看到，第三次传球后小蛮有两种可能性手上有球，分别是1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，因此我们知道了每次把有球的人的旁边两个人加上这个人的可能次数，就可以得到正确结果。（这其实就是小学奥数传球法） 2.编程思路 上面的一句话有一些难懂，这里用代码解释一下： a[j+1]+=a[j]; a[j-1]+=a[j]; 所以，我们的任务就是模拟这个过程。 注意： 1.不应该用数值来判断是否到边界（0或n），而应该用下标来判断 2.a[j]不能直接为零，而是减去上一次传球的可能次数（因为可能不仅他要传给别人，别人也要传给他） 对应解决方案： 1.改为j-1和j+1 2.使用一个b数组来存储上一次的 3.AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int mm=40; int n,m; int a[mm],b[mm]; int main() { //读入 cin&gt;&gt;n&gt;&gt;m; a[1]=b[1]=1; //循环m次传球 for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { //分不同情况处理，这里开两个数组，类似于差分操作 if(a[j]&gt;=1) { if(j-1&lt;1) { a[n]+=b[j]; } else { a[j-1]+=b[j]; } if(j+1&gt;n) { a[1]+=b[j]; } else { a[j+1]+=b[j]; } a[j]-=b[j]; } } //加起来 for(int j=1;j&lt;=n;j++) { b[j]=a[j]; } } //输出1号也就是小强的可能传到数量 cout&lt;&lt;a[1]; return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1057/"},{"title":"洛谷 P2799 国王的魔镜","content":"P2799 国王的魔镜 题解 题目链接 序言： 我看题解中各种方法我这个蒟蒻都理解不了，所以我决定来发一篇模拟也能AC的代码。 1.入手程序 根据题意，我们的模拟过程就是倒退项链的变化过程。那么项链在什么情况下可以增长呢？不妨先看看样例： ABBAABBA 2 样例中的项链的变化过程如下： AB-&gt;ABBA-&gt;ABBAABBA 因此，可以推导出两条规则： （1）项链只要变化过，它的长度就一定是偶数。 （2）项链只要变化过，它就一定是一个回文字符串（类似于回文数）。 2.编程思路 上面推导出了两项规则，但是还不足以帮助我们来模拟项链变化过程，因为它是正向的，于是继续推导,终于推出了代码的核心! 如果项链的长度是偶数且回文，它就有可能是变化过的。 并且由于我们要求最初的项链可能的最小长度，所以就意味着...... 如果项链的长度是偶数且回文，它项链的长度就能缩短！ 所以，我们的任务就是模拟这个过程。 3.AC代码 终于到了激动人心的AC时刻！ #include&lt;bits/stdc++.h&gt; using namespace std; string s; //递归倒推 int mj(string s) { int sl=s.size(); //如果是奇数就一定是最开始的结果 if(sl%2==1) { return sl; } string s2=s; reverse(s2.begin(),s2.end());//rerse函数是判断一个字符串是否回文的一个工具，具体用法为：reverse(字符串.begin(),字符串.end()) //如果是偶数就据续处理 if(s==s2) { string ts; for(int i=1;i&lt;=sl/2;i++) { ts+=s[i-1]; } return mj(ts); } return sl; } int main()//好短的主函数啊~ { cin&gt;&gt;s; cout&lt;&lt;mj(s);//直接输出处理后的结果 return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P2799/"},{"title":"洛谷 P1417 烹调方案","content":"P1417 烹调方案 题解 题目链接 序言： 最近在练DP，刷到了这道题，众所周知，DP最重要的是有大佬给出能推出状态转移方程，这题就是这样的一题~ 1.入手程序 一看：嗯~是一道明显的DP 再看：咦~好像不对劲，这是什么？ 如果在t时刻完成第i样食材则得到ai-t*bi的美味指数 一想：啊~ 原来不是基本DP啊，看起来好难溜了溜了 再想：嘿~ 怎么能这样轻易放弃呢！ 开始推状态转移方程！ 2.编程思路 首先，这个题状态转移方程难推的地方在于，因为有b[i]的存在，一件食材先后制作获得的美味指数不同，那么~ sort大法好！ cmp怎么写呢？ 慢慢推吧~ （强烈建议此时在看题解的你停下来推一下） 推完了么？ 往下看吧???? 关于每两个食材i和j，先做i和先做j的美味指数分别为： 1.a[i]-(t+c[i])*b[i]+a[j]-(t+c[i]+c[j])*b[j] 2.a[j]-(t+c[j])*b[j]+a[i]-(t+c[i]+c[j])*b[i] 如果1&gt;2： a[i]-t*b[i]-c[i]*b[i]+a[j]-t*b[j]-c[i]*b[j]-c[j]*b[j]&gt; a[j]-t*b[j]-c[j]*b[j]+a[i]-t*b[i]-c[i]*b[i]-c[j]*b[i] ↓ -t*b[i]-c[i]*b[i]-t*b[j]-c[i]*b[j]-c[j]*b[j]&gt; -t*b[j]-c[j]*b[j]-t*b[i]-c[i]*b[i]-c[j]*b[i] ↓ -c[i]*b[j]&gt;-c[j]*b[i] ok~ 羌湖~ 起飞~ 嗯嗯，还有一句话想说 十年OI一场空，不开long long见祖宗 3.AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; struct Node { long long a,b,c; }s[55]; long long t,n; long long dp[100005]; long long ans; bool cmp(Node x,Node y) { return -x.c*y.b&gt;-y.c*x.b;//这短短的一行，我推了多久啊。。。 } int main() { //读入 cin&gt;&gt;t&gt;&gt;n; for(long long i=1;i&lt;=n;i++)//其实这些地方可以不开long long { cin&gt;&gt;s[i].a; } for(long long i=1;i&lt;=n;i++) { cin&gt;&gt;s[i].b; } for(long long i=1;i&lt;=n;i++) { cin&gt;&gt;s[i].c; } //排序 sort(s+1,s+1+n,cmp);//sort大法好！ //01背包dp for(long long i=1;i&lt;=n;i++) { for(long long j=t;j&gt;=s[i].c;j--) { dp[j]=max(dp[j],dp[j-s[i].c]+s[i].a-s[i].b*j); ans=max(ans,dp[j]); } } //输出 cout&lt;&lt;ans; return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1417/"},{"title":"洛谷 P1125 笨小猴","content":"P1125 笨小猴 题解 题目链接 序言： 以前没过审的一篇博客，再写一遍吧，留作纪念 1. 入手程序 这句话是我们入手的关键↓ 一个单词，其中只可能出现小写字母，并且长度小于100 这说明数据很小，小到可以.. 暴力模拟 2. 编程思路 读入 通过ASCLL码记录每个字母出现个数。 寻找出现次数最多的字母的出现个数 寻找出现次数最少的字母的出现个数 判断加输出 注意 质数的特判 本题中maxn-minn可能等于0或1！（感谢样例二） if(x==0 || x==1) { return 0; } 寻找出现次数最少的字母时的特判 不是所有字母都一定要出现在一个单词里！所以次数可能是0！ if(z[i]&lt;small &amp;&amp; z[i]!=0) { small=z[i]; } 3. AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; string s;//读入的单词 int z[30];//记录每个字母出现了多少次。 int sf(int x)//判断质数，不多解释 { if(x==0 || x==1) { return 0; } for(int i=2;i&lt;=sqrt(x);i++) { if(x%i==0) { return 0; } } return 1; } int main() { cin&gt;&gt;s; //读入 int l=s.size(); for(int i=0;i&lt;l;i++) //通过ASCLL码记录每个字母出现个数。 { z[int(char(s[i]))-96]++; } int big=0; for(int i=1;i&lt;=26;i++)//寻找出现次数最多的字 母的出现个数 { if(z[i]&gt;big) { big=z[i]; } } int small=101; for(int i=1;i&lt;=26;i++)//寻找出现次数最少的字母的出现个数 { if(z[i]&lt;small &amp;&amp; z[i]!=0) { small=z[i]; } } if(sf(big-small)==1)//判断输出 { cout&lt;&lt;&quot;Lucky Word&quot;&lt;&lt;endl&lt;&lt;big-small; } else{ cout&lt;&lt;&quot;No Answer&quot;&lt;&lt;endl&lt;&lt;&quot;0&quot;; } return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1125/"},{"title":"洛谷 P1112 波浪数","content":"P1112 波浪数 题解 题目链接 序言：以后想不出序言说什么就放一句名言吧 我们都是阴沟里的虫子,但总还是得有人仰望星空 ——刘慈欣 《三体》 1. 入手程序 第一步，分析数据，暴力肯定不行 第二部，考虑是否可以模拟，发现虽然不能纯模拟，但可以使用... 构造法 2. 编程思路 所谓的构造法，指的是逆向的通过枚举或其他方法来构造出题目要求的数或情况 具体到这一题，就是枚举i进制下j，k轮流出现构成的波浪数的存在并存到对应重数数组下 最后将题目要求的重数输出出来 注意： 一位数也可以是波浪数 波浪数轮流出现的两个数不能一样 波浪数不一定要是“ababab...”形式，也可以是“abababa...”形式 一个波浪数不一定一定要在十进制下是波浪数 3. AC代码 #include&lt;bits/stdc++.h&gt; using namespace std; int m[10000005];//存重数 int a,b,c,d,e; int main() { cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e; for(int i=a;i&lt;=b;i++)//在i进制下 { for(int j=0;j&lt;i;j++)//枚举第一个数 { for(int k=1;k&lt;i;k++)//枚举第二个数 { if(j!=k)//两数不能一样 { int v1=0;//构造用 int v2=0;//计数 用 while(v1&lt;=d) { //循环用两个数构造 if(v2%2==0) { v1=v1*i+j; } else { v1=v1*i+k; } v2++; if(v1&gt;=c &amp;&amp; v1&lt;=d) { m[v1]++;//如果是波浪数，存到对应位置 } } } } } } for(int i=c;i&lt;=d;i++) { if(m[i]==e)//如果有题目要求的重数，输出 { cout&lt;&lt;i&lt;&lt;endl; } } return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P1112/"},{"title":"洛谷 P3369 【模板】普通平衡树","content":"P3369 【模板】普通平衡树 题解 题目链接 序言：调了超久的一道题！向提高组冲击的第一步！treap！ 1. 入手程序 模板题么，就没什么思路了，既然是练习treap，直接开整呗~ 2. 编程思路 首先，Treap=Tree+Heap，Tree指的是二叉排序树，Heap则是指堆 它融合了二叉排序树的优点：操作方便、多样 同时使用堆结构规避了二叉排序树容易退化成一条链的问题 剩下的看代码吧~ 放心，注释多到爆炸 3. AC代码 /* size[i] 以i为根的子树的节点数 v[i] i节点的权值 num[i] 由于可能有重复（上文讲的是没有重复的），所以，我们将权值一样的存在一个节点里面，num数组存储的是i节点存的个数 son[i][2] 存储i节点的儿子，注意，这里不是完全二叉树所以需要存储儿子，son[i][0]表示左儿子，son[i][1]表示右儿子。 rd[i] i节点的一个随机值 */ #include&lt;bits/stdc++.h&gt; using namespace std; const int MAX=100500; int n; int size[MAX],num[MAX],v[MAX],son[MAX][2],rd[MAX]; int x,opt,r,sum;//x,opt与题干中同义，sum为节点个数 void gx(int g)//更新节点个数 { size[g]=size[son[g][0]]+size[son[g][1]]+num[g]; //g的节点数=左右儿子节点数之和+g本身存有数量 } void xz(int &amp;g,int d)//旋转，以g为根，d=0左旋，反之右旋 { //x^1时,如果x为偶数则为x+1，否则为x-1 //这里相当于1变0，0变1 int v1=son[g][d^1];//左旋时，v1为g的右儿子，反之为g的左儿子 son[g][d^1]=son[v1][d]; //左旋时，g的右儿子变成v1的左儿子,反之g的左儿子变成v1的右儿子 son[v1][d]=g; //左旋时，v1的左儿子变成g,反之v1的右儿子变成g gx(g); gx(v1); //更新父节点子节点个数 g=v1;//最后换根 } void cr(int &amp;g,int x)//插入，以g为根，插入x { if(!g)//空树 { g=++sum;//节点总数加1 size[g]=num[g]=1;//于是有1个节点在树中了,当前节点有1个重复数字 v[g]=x;//值为x rd[g]=rand();//生成随机值，拿来维护堆 return; } if(v[g]==x)//已有该权值，那么直接个数加加即可 { num[g]++; size[g]++; return; } //继续向下寻找 int v1=(x&gt;v[g]);//左儿子或右二子 cr(son[g][v1],x); if(rd[g]&lt;rd[son[g][v1]])//这样转不破坏堆的性质 { xz(g,v1^1);//旋转 //x^1时,如果x为偶数则为x+1，否则为x-1 //这里相当于1变0，0变1 } gx(g);//更新父节点子节点个数 } void sc(int &amp;g,int x)//根为g，删除x { if(!g)//空节点，不可能有要删的这个点 { return; } //如果x和v[g]不相等，直接转到相应子树解决问题 if(x&lt;v[g]) { sc(son[g][0],x); } else if(x&gt;v[g]) { sc(son[g][1],x); } else//就在这棵树 { if(!son[g][0] &amp;&amp; !son[g][1]) //木有在节点啦，x是叶子节点 { num[g]--; size[g]--; //扣掉个数 if(num[g]==0)//如果没数了，删除节点 { g=0; } } else if(son[g][0] &amp;&amp; !son[g][1]) { xz(g,1);//转~ sc(son[g][1],x); } else if(!son[g][0] &amp;&amp; son[g][1]) { xz(g,0);//转~ sc(son[g][0],x); } else if(son[g][0] &amp;&amp; son[g][1])//俩都有，转大的 { int v1=(rd[son[g][0]]&gt;rd[son[g][1]]);//按随机值排，完美避开强迫症~ xz(g,v1);//转~ sc(son[g][v1],x); } } gx(g); } int pm(int &amp;g,int x)//根为g,查询x的排名 { if(!g)//空空如也~ { return 0; } if(v[g]==x)//返回左子树个数+1 { return size[son[g][0]]+1; } if(v[g]&lt;x)//x在右子树，返回左子树个数+在右子树的排名 { return size[son[g][0]]+num[g]+pm(son[g][1],x); } if(v[g]&gt;x)//x在左子树，返回在左子树的排名 { return pm(son[g][0],x); } } int cx(int &amp;g,int x) { if(g==0)//又是空空如也~ { return 0; } if(size[son[g][0]]&gt;=x)//左子树节点数&gt;x，在左节点里找 { return cx(son[g][0],x); } else if(size[son[g][0]]+num[g]&lt;x)//左节点节点数&lt;x，查右子树的第x-左子树节点个数-根储存个数 { return cx(son[g][1],x-num[g]-size[son[g][0]]); } else//当前就是要找的 { return v[g]; } } int qq(int g,int x)//根为g，求x的前驱 { if(g==0)//还是空空如也~ { return -2000000005; } else if(v[g]&gt;=x)//在根或右子树，去左子树找 { return qq(son[g][0],x); } else//在左子树，取根和右子树最大的那一个 { return max(v[g],qq(son[g][1],x)); } } int hj(int g,int x)//根为g，求x的后继 { if(g==0)//依旧空空如也~ { return 2000000005; } if(v[g]&lt;=x)//在根或左子树，去右子树找 { return hj(son[g][1],x); } else//在左子树，取根或右子树最小的那一个 { return min(v[g],hj(son[g][0],x)); } } int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;opt&gt;&gt;x; if(opt==1)//插入 x 数 { cr(r,x); } else if(opt==2)//删除 x 数(若有多个相同的数，因只删除一个) { sc(r,x); } else if(opt==3)//查询 x 数的排名(排名定义为比当前数小的数的个数 +1 ) { cout&lt;&lt;pm(r,x)&lt;&lt;endl; } else if(opt==4)//查询排名为 x 的数 { cout&lt;&lt;cx(r,x)&lt;&lt;endl; } else if(opt==5)//求 x 的前驱(前驱定义为小于 x，且最大的数) { cout&lt;&lt;qq(r,x)&lt;&lt;endl; } else if(opt==6)//求 x 的后继(后继定义为大于 x，且最小的数) { cout&lt;&lt;hj(r,x)&lt;&lt;endl; } } return 0; } 我是千文杜博，记住我呦~~ The end ","link":"https://qwdb.github.io/post/P3369/"}]}